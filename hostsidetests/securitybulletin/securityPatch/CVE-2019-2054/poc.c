/**
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include <err.h>
#include <errno.h>
#include <linux/elf.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ptrace.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/uio.h>
#include <sys/wait.h>
#include <unistd.h>

#include "../includes/common.h"

time_t test_started;

int main(void) {
  pid_t my_pid = -1;

  setbuf(stdout, NULL);

  pid_t child = fork();

  switch (child) {
    case -1:
      // child = -1 => the creation of a child process was unsuccessful.
      err(1, "fork");
      return EXIT_FAILURE;

    case 0:
      // child = 0 => Returned to the newly created child process
      my_pid = getpid();
      test_started = start_timer();

      while (timer_active(test_started)) {
        errno = 0;
        int res = syscall(__NR_gettid, 0, 0);
        if (res != my_pid) {
          printf("%d (%s)\n", res, strerror(errno));
          return EXIT_VULNERABLE;
        }
      }
      return EXIT_SUCCESS;

    default:
      // child > 0 => Returned to parent process.
      // The value contains process ID of its newly created child process.
      sleep(1);

      if (ptrace(PTRACE_ATTACH, child, NULL, NULL)) {
        err(1, "main() : ptrace attach");
        return EXIT_FAILURE;
      }

      int status;
      if (waitpid(child, &status, 0) != child) {
        err(1, "main() : wait for child");
        return EXIT_FAILURE;
      }

      if (ptrace(PTRACE_SYSCALL, child, NULL, NULL)) {
        err(1, "main() : ptrace syscall entry");
        return EXIT_FAILURE;
      }

      if (waitpid(child, &status, 0) != child) {
        err(1, "main() : wait for child");
        return EXIT_FAILURE;
      }

      int syscallno;
      struct iovec iov = {.iov_base = &syscallno, .iov_len = sizeof(syscallno)};

      if (ptrace(PTRACE_GETREGSET, child, NT_ARM_SYSTEM_CALL, &iov)) {
        err(1, "main() : ptrace getregs");
        return EXIT_FAILURE;
      }

      printf("main() : seeing syscall %d\n", syscallno);
      if (syscallno != __NR_gettid) {
        err(1, "main() : not gettid");
        return EXIT_FAILURE;
      }

      syscallno = __NR_swapon;
      if (ptrace(PTRACE_SETREGSET, child, NT_ARM_SYSTEM_CALL, &iov)) {
        err(1, "main() : ptrace setregs");
        return EXIT_FAILURE;
      }

      if (ptrace(PTRACE_DETACH, child, NULL, NULL)) {
        err(1, "main() : ptrace syscall");
        return EXIT_FAILURE;
      }
      // kill child proces
      int killRet = kill(child, SIGCONT);
      if (killRet == -1) {
        printf(
            "main() : killing child process(%d) with SIGCONT on error (%s)\n",
            child, strerror(errno));
      }

      // wait for child process stop
      int waitPid = waitpid(child, &status, 0);
      if (waitPid == -1) {
        perror("main() waitpid: waitpid = -1 and continue wait");
        return EXIT_FAILURE;
      }

      if (WIFEXITED(status)) {
        //  detected vulnarable exit status of child process
        printf("main() : Exit Vulnerable: child = %d, status=%d\n", child, WEXITSTATUS(status));
        return WEXITSTATUS(status);
      }
      break;
  }

  return EXIT_SUCCESS;
}