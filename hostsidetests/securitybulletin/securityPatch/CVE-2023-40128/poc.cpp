/*
 * Copyright (C) 2024 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include <dlfcn.h>
#include <libxml/xmlregexp.h>

#include <cstring>

#include "../includes/common.h"

// Mock structure definitions
typedef struct _xmlRegCounter {
    int min;
    int max;
} xmlRegCounter;

bool is_memutils_initialized = false;
bool testInProgress = false;

static void *(*real_malloc)(size_t) = NULL;
struct sigaction new_action, old_action;

void sigsegv_handler(int signum, siginfo_t *info, void *context) {
    xmlRegCounter *counter_ptr = (xmlRegCounter *)NULL;
    if ((void *)&counter_ptr[-1] == info->si_addr) {
        (*old_action.sa_sigaction)(signum, info, context);
        return;
    }
    exit(EXIT_FAILURE);
}

// Initialize memory utilities (mocking malloc)
void initialize_memutils(void) {
    real_malloc = (void *(*)(size_t))dlsym(RTLD_NEXT, "malloc");
    FAIL_CHECK(real_malloc);
    is_memutils_initialized = true;
}

// Overloading malloc function
void *malloc(size_t size) {
    if (!is_memutils_initialized) {
        initialize_memutils();
    }
    if (testInProgress && size == (sizeof(xmlRegCounter) * 4)) {
        return NULL;
    }
    return real_malloc(size);
}

int main() {
    // Setup signal handler
    sigemptyset(&new_action.sa_mask);
    new_action.sa_flags = SA_SIGINFO;
    new_action.sa_sigaction = sigsegv_handler;
    sigaction(SIGSEGV, &new_action, &old_action);

    // XML Automata setup
    xmlAutomataPtr automata = xmlNewAutomata();
    xmlAutomataStatePtr initial_state, final_state;
    initial_state = xmlAutomataGetInitState(automata);
    final_state = NULL;

    // Create a sample token for XML transitions
    unsigned char token_buffer[2];
    memset(token_buffer, 1 /* val */, sizeof(token_buffer));
    const xmlChar *transition_token = token_buffer;

    // In the vulnerable function, to bypass the checks 'if (min < 1) return NULL' and
    // 'if (max < min) return NULL'. The values of 'min' is set to 2 and 'max' to 3,
    // ensuring that the function doesn't exit early.
    // Without the fix, 'xmlAutomataNewOnceTrans()' attempts to access OOB memory, which is detected
    // by memutils and results in segmentation fault
    testInProgress = true;
    xmlAutomataNewOnceTrans(automata, initial_state, final_state, transition_token, 2 /* min */,
                            3 /* max */, NULL);
    testInProgress = false;
    return EXIT_SUCCESS;
}
