/*
 * Copyright (C) 2021 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at:
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

#include "gui/IRegionSamplingListener.h"
#include "SurfaceFlinger.h"
#include "../includes/common.h"

bool testInProgress = false;

struct sigaction new_action, old_action;
void sigbus_handler(int signum, siginfo_t* info, void* context) {
    if (testInProgress && info->si_signo == SIGBUS) {
        (*old_action.sa_sigaction)(signum, info, context);
        return;
    }
    _exit(EXIT_FAILURE);
}

class NewBinder : public android::IBinder {
 public:
    constexpr static uint32_t arraySize = 16;
    constexpr static uint32_t elementValue = 0x11111111;
    uint32_t arr[arraySize] = { };

    NewBinder() {
        for (uint32_t i = 0; i < arraySize; ++i) {
            arr[i] = elementValue;
        }
    }

    const android::String16& getInterfaceDescriptor() const {
        static android::String16 sEmptyDescriptor;
        return sEmptyDescriptor;
    }

    bool isBinderAlive() const {
        return true;
    }

    android::status_t pingBinder() {
        return android::NO_ERROR;
    }

    android::status_t dump(int /* fd */,
                           const android::Vector<android::String16>& /* args */) {
        return android::NO_ERROR;
    }

    android::status_t transact(uint32_t /* code */,
                               const android::Parcel& /* data */,
                               android::Parcel* /* reply */, uint32_t /* flags */) {
        return android::NO_ERROR;
    }

    android::status_t linkToDeath(
            const android::sp<android::IBinder::DeathRecipient>& /* recipient */,
            void* /* cookie */, uint32_t /* flags */) {
        return android::NO_ERROR;
    }

    android::status_t unlinkToDeath(
            const android::wp<android::IBinder::DeathRecipient>& /* recipient */,
            void* /* cookie */, uint32_t /* flags */,
            android::wp<android::IBinder::DeathRecipient>* /* outRecipient */) {
        return android::NO_ERROR;
    }

    void attachObject(const void* /* objectID */, void* /* object */,
                      void* /* cleanupCookie */, object_cleanup_func /* func */) {
    }

    void* findObject(const void* /* objectID */) const {
        return nullptr;
    }

    void detachObject(const void* /* objectID */) {
    }

    android::BBinder* localBinder() {
        return nullptr;
    }

    android::BpBinder* remoteBinder() {
        return reinterpret_cast<android::BpBinder*>(this);
    }
};

class Listener : public android::BnRegionSamplingListener {
 public:
    void onSampleCollected(float /* medianLuma */) {
    }
};

int main() {
    sigemptyset(&new_action.sa_mask);
    new_action.sa_flags = SA_SIGINFO;
    new_action.sa_sigaction = sigbus_handler;
    sigaction(SIGBUS, &new_action, &old_action);

    android::sp<Listener> listener = new Listener();
    FAIL_CHECK(listener);

    const android::Rect sampleArea { 100, 100, 200, 200 };
    const android::sp<android::IBinder> &stopLayerHandle = new NewBinder();
    FAIL_CHECK(stopLayerHandle);

    android::sp < android::SurfaceFlinger > flinger =
            android::surfaceflinger::createSurfaceFlinger();
    FAIL_CHECK(flinger);

    android::sp < android::ISurfaceComposer > composer = flinger;
    testInProgress = true;
    android::status_t status =
            composer->addRegionSamplingListener(sampleArea, stopLayerHandle, listener);
    testInProgress = false;
    FAIL_CHECK(status == android::NO_ERROR);

    return EXIT_SUCCESS;
}
