/*
 * Copyright (C) 2024 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "../includes/common.h"
#include "../includes/memutils.h"
#include "binary_loader.h"
#include "src/dec/vp8li_dec.h"
#include "src/dec/webpi_dec.h"

char enable_selective_overload = ENABLE_NONE;

typedef int (*VP8LDecodeHeaderFunc)(void* dec, void* io);

int main(int /* argc */, char* argv[]) {
    // Get the absoulute path to the shared library 'libhwui'
    const char* libPath = argv[1];
    uintptr_t functionOffset = strtoul(argv[2], NULL, 0);

    // Load 'libhwui' lib and get offset of VP8LDecodeHeader()
    BinaryLoader binaryLoader(libPath);
    uintptr_t functionAddress = binaryLoader.getFunctionAddress(functionOffset);
    FAIL_CHECK(functionAddress);

    // Read image data from file
    size_t data_size = 0;
    FILE* file = fopen("cve_2023_4863", "rb");
    if (file) {
        fseek(file, 0, SEEK_END); // Seek to the end of the file
        data_size = ftell(file);  // Get the current file pointer (which is the file size)
        rewind(file);             // Set the file position indicator to the beginning of the file
    }
    uint8_t data[data_size];
    fread(data, sizeof(uint8_t), data_size, file);
    fclose(file);

    // Create VP8Io object
    VP8Io io{};
    WebPHeaderStructure headers;
    headers.data = data;
    headers.data_size = data_size;
    headers.have_all_data = 1;
    WebPParseHeaders(&headers);
    io.data = headers.data + headers.offset;
    io.data_size = headers.data_size - headers.offset;

    // Call VP8LDecodeHeader() with VP8LDecoder instance and io.
    // Without fix, an OOB write occurs in BuildHuffmanTable() which leads to test failure.
    // With fix, a NPD is seen in BuildHuffmanTable() and the test passes.
    enable_selective_overload = ENABLE_ALL;
    ((VP8LDecodeHeaderFunc)functionAddress)(VP8LNew(), &io);
    enable_selective_overload = ENABLE_FREE_CHECK | ENABLE_REALLOC_CHECK;
    return 0;
}
