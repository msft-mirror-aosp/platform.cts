/**
 * Copyright (C) 2021 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
This PoC is written taking reference from frameworks/base/native/graphics/jni/imagedecoder.cpp
and frameworks/base/libs/hwui/hwui/ImageDecoder.cpp
*/

#include <SkAndroidCodec.h>
#include <SkCanvas.h>
#include <SkPngChunkReader.h>
#include <binder/IPCThreadState.h>
#include <hwui/Bitmap.h>
#include <vector>
#include "../includes/common.h"

using namespace android;

constexpr int32_t kMaxDimension = 5000;

struct AImageDecoder;
typedef struct AImageDecoder AImageDecoder;

struct AImageDecoderHeaderInfo;
typedef struct AImageDecoderHeaderInfo AImageDecoderHeaderInfo;

class ImageDecoder {
   public:
    std::unique_ptr<SkAndroidCodec> mCodec;
    sk_sp<SkPngChunkReader> mPeeker;

    ImageDecoder(std::unique_ptr<SkAndroidCodec> codec, sk_sp<SkPngChunkReader> peeker = nullptr);
    bool setTargetSize(int width, int height);
    bool setCropRect(const SkIRect *);
    bool setOutColorType(SkColorType outColorType);
    bool setUnpremultipliedRequired(bool unpremultipliedRequired);
    sk_sp<SkColorSpace> getDefaultColorSpace() const;
    void setOutColorSpace(sk_sp<SkColorSpace> cs);
    SkImageInfo getOutputInfo() const;
    bool opaque() const;
    bool gray() const;
    SkCodec::Result decode(void *pixels, size_t rowBytes);

   private:
    SkISize mTargetSize;
    SkISize mDecodeSize;
    SkColorType mOutColorType;
    bool mUnpremultipliedRequired;
    sk_sp<SkColorSpace> mOutColorSpace;
    int mSampleSize;
    std::optional<SkIRect> mCropRect;

    ImageDecoder(const ImageDecoder &) = delete;
    ImageDecoder &operator=(const ImageDecoder &) = delete;
    SkAlphaType getOutAlphaType() const;
    sk_sp<SkColorSpace> getOutputColorSpace() const;
};

enum {
    ANDROID_IMAGE_DECODER_SUCCESS = 0,
    ANDROID_IMAGE_DECODER_INCOMPLETE = -1,
    ANDROID_IMAGE_DECODER_ERROR = -2,
    ANDROID_IMAGE_DECODER_INVALID_CONVERSION = -3,
    ANDROID_IMAGE_DECODER_INVALID_SCALE = -4,
    ANDROID_IMAGE_DECODER_BAD_PARAMETER = -5,
    ANDROID_IMAGE_DECODER_INVALID_INPUT = -6,
    ANDROID_IMAGE_DECODER_SEEK_ERROR = -7,
    ANDROID_IMAGE_DECODER_INTERNAL_ERROR = -8,
    ANDROID_IMAGE_DECODER_UNSUPPORTED_FORMAT = -9
};

static ImageDecoder *toDecoder(AImageDecoder *d) { return reinterpret_cast<ImageDecoder *>(d); }

int ResultToErrorCode(SkCodec::Result result) {
    switch (result) {
        case SkCodec::kIncompleteInput:
            return ANDROID_IMAGE_DECODER_INCOMPLETE;
        case SkCodec::kErrorInInput:
            return ANDROID_IMAGE_DECODER_ERROR;
        case SkCodec::kInvalidInput:
            return ANDROID_IMAGE_DECODER_INVALID_INPUT;
        case SkCodec::kCouldNotRewind:
            return ANDROID_IMAGE_DECODER_SEEK_ERROR;
        case SkCodec::kUnimplemented:
            return ANDROID_IMAGE_DECODER_UNSUPPORTED_FORMAT;
        case SkCodec::kInvalidConversion:
            return ANDROID_IMAGE_DECODER_INVALID_CONVERSION;
        case SkCodec::kInvalidParameters:
            return ANDROID_IMAGE_DECODER_BAD_PARAMETER;
        case SkCodec::kSuccess:
            return ANDROID_IMAGE_DECODER_SUCCESS;
        case SkCodec::kInvalidScale:
            return ANDROID_IMAGE_DECODER_INVALID_SCALE;
        case SkCodec::kInternalError:
            return ANDROID_IMAGE_DECODER_INTERNAL_ERROR;
    }
}

sk_sp<SkColorSpace> ImageDecoder::getDefaultColorSpace() const { return SkColorSpace::MakeSRGB(); }

ImageDecoder::ImageDecoder(std::unique_ptr<SkAndroidCodec> codec, sk_sp<SkPngChunkReader> peeker)
    : mCodec(std::move(codec)),
      mPeeker(std::move(peeker)),
      mTargetSize(mCodec->getInfo().dimensions()),
      mDecodeSize(mTargetSize),
      mOutColorType(mCodec->computeOutputColorType(kN32_SkColorType)),
      mUnpremultipliedRequired(false),
      mOutColorSpace(getDefaultColorSpace()),
      mSampleSize(1) {}

static int createFromStream(std::unique_ptr<SkStreamRewindable> stream,
                            AImageDecoder **outDecoder) {
    SkCodec::Result result;
    auto codec = SkCodec::MakeFromStream(std::move(stream), &result, nullptr);
    auto androidCodec = SkAndroidCodec::MakeFromCodec(
        std::move(codec), SkAndroidCodec::ExifOrientationBehavior::kRespect);
    if (!androidCodec) {
        return ResultToErrorCode(result);
    }
    const auto &info = androidCodec->getInfo();
    if (info.width() > std::numeric_limits<int32_t>::max() ||
        info.height() > std::numeric_limits<int32_t>::max()) {
        return ANDROID_IMAGE_DECODER_INVALID_INPUT;
    }
    *outDecoder = reinterpret_cast<AImageDecoder *>(new ImageDecoder(std::move(androidCodec)));
    return ANDROID_IMAGE_DECODER_SUCCESS;
}

int AImageDecoder_createFromBuffer(const void *buffer, size_t length, AImageDecoder **outDecoder) {
    if (!buffer || !length || !outDecoder) {
        return ANDROID_IMAGE_DECODER_BAD_PARAMETER;
    }
    *outDecoder = nullptr;
    auto stream = std::unique_ptr<SkStreamRewindable>(
        new SkMemoryStream(buffer, length, false /* copyData */));
    return createFromStream(std::move(stream), outDecoder);
}

void AImageDecoder_delete(AImageDecoder *decoder) { delete toDecoder(decoder); }

struct DecoderDeleter {
    void operator()(AImageDecoder *decoder) const { AImageDecoder_delete(decoder); }
};

using DecoderPointer = std::unique_ptr<AImageDecoder, DecoderDeleter>;

DecoderPointer makeDecoder(const uint8_t *data, size_t size) {
    AImageDecoder *decoder = nullptr;
    int result = AImageDecoder_createFromBuffer(data, size, &decoder);
    if (result != ANDROID_IMAGE_DECODER_SUCCESS) {
        return nullptr;
    }
    return DecoderPointer(decoder);
}

const AImageDecoderHeaderInfo *AImageDecoder_getHeaderInfo(const AImageDecoder *decoder) {
    return reinterpret_cast<const AImageDecoderHeaderInfo *>(decoder);
}

static const ImageDecoder *toDecoder(const AImageDecoderHeaderInfo *info) {
    return reinterpret_cast<const ImageDecoder *>(info);
}

int32_t AImageDecoderHeaderInfo_getWidth(const AImageDecoderHeaderInfo *info) {
    if (!info) {
        return 0;
    }
    return toDecoder(info)->mCodec->getInfo().width();
}

int32_t AImageDecoderHeaderInfo_getHeight(const AImageDecoderHeaderInfo *info) {
    if (!info) {
        return 0;
    }
    return toDecoder(info)->mCodec->getInfo().height();
}

bool ImageDecoder::opaque() const { return mCodec->getInfo().alphaType() == kOpaque_SkAlphaType; }

sk_sp<SkColorSpace> ImageDecoder::getOutputColorSpace() const {
    return mOutColorType == kGray_8_SkColorType ? nullptr : mOutColorSpace;
}

SkAlphaType ImageDecoder::getOutAlphaType() const {
    return opaque() ? kOpaque_SkAlphaType
                    : mUnpremultipliedRequired ? kUnpremul_SkAlphaType : kPremul_SkAlphaType;
}

SkImageInfo ImageDecoder::getOutputInfo() const {
    SkISize size = mCropRect ? mCropRect->size() : mTargetSize;
    return SkImageInfo::Make(size.fWidth, size.fHeight, mOutColorType, getOutAlphaType(),
                             getOutputColorSpace());
}

size_t AImageDecoder_getMinimumStride(AImageDecoder *decoder) {
    if (!decoder) {
        return 0;
    }
    SkImageInfo info = toDecoder(decoder)->getOutputInfo();
    return info.minRowBytes();
}

SkCodec::Result ImageDecoder::decode(void *pixels, size_t rowBytes) {
    void *decodePixels = pixels;
    size_t decodeRowBytes = rowBytes;
    auto decodeInfo = SkImageInfo::Make(mDecodeSize.fWidth, mDecodeSize.fHeight, mOutColorType,
                                        getOutAlphaType(), getOutputColorSpace());
    SkBitmap tmp;
    const bool scale = mDecodeSize != mTargetSize;
    if (scale || mCropRect) {
        if (!tmp.setInfo(decodeInfo)) {
            return SkCodec::kInternalError;
        }
        if (!Bitmap::allocateHeapBitmap(&tmp)) {
            return SkCodec::kInternalError;
        }
        decodePixels = tmp.getPixels();
        decodeRowBytes = tmp.rowBytes();
    }
    SkAndroidCodec::AndroidOptions options;
    options.fSampleSize = mSampleSize;
    auto result = mCodec->getAndroidPixels(decodeInfo, decodePixels, decodeRowBytes, &options);
    if (scale || mCropRect) {
        SkBitmap scaledBm;
        if (!scaledBm.installPixels(getOutputInfo(), pixels, rowBytes)) {
            return SkCodec::kInternalError;
        }
        SkPaint paint;
        paint.setBlendMode(SkBlendMode::kSrc);
        paint.setFilterQuality(kLow_SkFilterQuality);  // bilinear filtering

        SkCanvas canvas(scaledBm, SkCanvas::ColorBehavior::kLegacy);
        if (mCropRect) {
            canvas.translate(-mCropRect->fLeft, -mCropRect->fTop);
        }
        if (scale) {
            float scaleX = (float)mTargetSize.width() / mDecodeSize.width();
            float scaleY = (float)mTargetSize.height() / mDecodeSize.height();
            canvas.scale(scaleX, scaleY);
        }
        canvas.drawBitmap(tmp, 0.0f, 0.0f, &paint);
    }
    return result;
}

int AImageDecoder_decodeImage(AImageDecoder *decoder, void *pixels, size_t stride, size_t size) {
    if (!decoder || !pixels || !stride) {
        return ANDROID_IMAGE_DECODER_BAD_PARAMETER;
    }
    ImageDecoder *imageDecoder = toDecoder(decoder);
    SkImageInfo info = imageDecoder->getOutputInfo();
    size_t minSize = info.computeByteSize(stride);
    if (SkImageInfo::ByteSizeOverflowed(minSize) || size < minSize || !info.validRowBytes(stride)) {
        return ANDROID_IMAGE_DECODER_BAD_PARAMETER;
    }
    return ResultToErrorCode(imageDecoder->decode(pixels, stride));
}

int main(int argc, char **argv) {
    FAIL_CHECK(argc >= 2);
    android::ProcessState::self()->startThreadPool();
    char *filename = argv[1];
    FILE *file = fopen(filename, "r");
    FAIL_CHECK(file);
    fseek(file, 0, SEEK_END);
    size_t size = ftell(file);
    fseek(file, 0, SEEK_SET);
    std::vector<uint8_t> buffer(size);
    fread((void *)buffer.data(), 1, size, file);
    fclose(file);
    DecoderPointer decoder = makeDecoder(buffer.data(), size);
    FAIL_CHECK(decoder);
    const AImageDecoderHeaderInfo *info = AImageDecoder_getHeaderInfo(decoder.get());
    int32_t width = AImageDecoderHeaderInfo_getWidth(info);
    int32_t height = AImageDecoderHeaderInfo_getHeight(info);
    FAIL_CHECK(width <= kMaxDimension && height <= kMaxDimension);
    size_t stride = AImageDecoder_getMinimumStride(decoder.get());
    size_t pixelSize = height * stride;
    std::vector<uint8_t> pixels(pixelSize);
    time_t test_started = start_timer();
    while (timer_active(test_started)) {
        int32_t result = AImageDecoder_decodeImage(decoder.get(), pixels.data(), stride, pixelSize);
        if (result != ANDROID_IMAGE_DECODER_SUCCESS) {
            break;
        }
    }
    return EXIT_SUCCESS;
}
