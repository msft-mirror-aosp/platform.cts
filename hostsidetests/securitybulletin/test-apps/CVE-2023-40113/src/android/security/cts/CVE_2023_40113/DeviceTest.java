/*
 * Copyright (C) 2024 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *s
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package android.security.cts.CVE_2023_40113;

import static android.content.Context.CONTEXT_IGNORE_SECURITY;
import static android.content.Context.CONTEXT_INCLUDE_CODE;
import static android.os.Build.VERSION.SDK_INT;

import static androidx.test.core.app.ApplicationProvider.getApplicationContext;

import static com.google.common.truth.Truth.assertWithMessage;
import static com.google.common.truth.TruthJUnit.assume;

import android.content.ContentProvider;
import android.content.ContentValues;
import android.content.Context;
import android.content.pm.ProviderInfo;
import android.net.Uri;
import android.os.UserHandle;

import androidx.test.runner.AndroidJUnit4;

import org.junit.Test;
import org.junit.runner.RunWith;

import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;

@RunWith(AndroidJUnit4.class)
public class DeviceTest {
    private Uri mContentUriForSms;
    private Uri mContentUriForMms;
    private boolean mIsClassSmsProvider;

    @Test
    public void testPocCVE_2023_40113() {
        try {
            // Create package context to load the 'MmsProvider', 'SmsProvider', and
            // 'MmsSmsProvider'
            final String telephonyPkg = "com.android.providers.telephony";
            final Context telephonyPkgContext =
                    getApplicationContext()
                            .createPackageContext(
                                    telephonyPkg, CONTEXT_IGNORE_SECURITY | CONTEXT_INCLUDE_CODE);

            // Fetch classloader for the package
            final ClassLoader telephonyPkgClassLoader = telephonyPkgContext.getClassLoader();

            // Load 'MmsProvider', 'SmsProvider', and 'MmsSmsProvider' class and create instance
            // of it to invoke vulnerable method.
            // Invoke 'query()', 'insert() / insertInner()', 'update()', and 'delete()' methods
            // to detect the vulnerability.
            // Fix prevents the managed user from accessing the SMS/MMS database.
            mContentUriForSms = Uri.parse("content://sms");
            mContentUriForMms = Uri.parse("content://mms");
            final ArrayList<String> listOfVulnerableMethods = new ArrayList<String>();
            for (String className : new String[] {"MmsProvider", "SmsProvider", "MmsSmsProvider"}) {
                mIsClassSmsProvider = className.equals("SmsProvider");
                listOfVulnerableMethods.addAll(
                        invokeVulnerableMethodsFor(
                                telephonyPkgContext,
                                telephonyPkgClassLoader,
                                String.format("%s.%s", telephonyPkg, className)));
            }

            // Check the list.
            // Fail the test if list is not empty.
            assertWithMessage(
                    "Device is vulnerable to b/289242655!!"
                            + " Telephony misses fix patch for : "
                            + listOfVulnerableMethods)
                    .that(listOfVulnerableMethods)
                    .isEmpty();
        } catch (Exception e) {
            assume().that(e).isNull();
        }
    }

    private ArrayList<String> invokeVulnerableMethodsFor(
            Context targetPkgContext, ClassLoader classLoader, String className) throws Exception {
        // Load target class and create instance of it
        final Class targetClass = classLoader.loadClass(className);
        final Object targetClassInstance = targetClass.newInstance();

        // Invoke the 'query()' method of target class to detect the vulnerability
        final ArrayList<String> listOfVulnerableMethods = new ArrayList<String>();
        if (query(targetPkgContext, targetClass, targetClassInstance)) {
            listOfVulnerableMethods.add(String.format("%s.query()", className));
        }

        // Invoke the 'insert()' method of target class to detect the vulnerability
        if (insert(targetClass, targetClassInstance)) {
            listOfVulnerableMethods.add(
                    String.format(
                            "%s.%s",
                            className, (mIsClassSmsProvider ? "insertInner()" : "insert()")));
        }

        // Invoke the 'update()' method of target class to detect the vulnerability
        if (update(targetClass, targetClassInstance)) {
            listOfVulnerableMethods.add(String.format("%s.update()", className));
        }

        // Invoke the 'delete()' method of target class to detect the vulnerability
        if (delete(targetClass, targetClassInstance)) {
            listOfVulnerableMethods.add(String.format("%s.delete()", className));
        }
        return listOfVulnerableMethods;
    }

    private boolean query(Context targetPkgContext, Class targetClass, Object targetClassInstance)
            throws Exception {
        // Set the 'mContext' of 'ContentProvider' for the created object of target class
        // to reliably detect the vulnerability
        final Field field = ContentProvider.class.getDeclaredField("mContext");
        field.setAccessible(true);
        field.set(targetClassInstance, targetPkgContext);

        // Invoke the 'attachInfo()' to set 'mCallingAttributionSource' of 'ContentProvider'
        Method attachInfoMethod = null;
        Class<?>[] parameterType;
        for (Method declaredMethod : ContentProvider.class.getDeclaredMethods()) {
            if ((declaredMethod.getName().equals("attachInfo"))
                    && (declaredMethod.getParameterCount() == 2)) {
                parameterType = declaredMethod.getParameterTypes();
                if ((parameterType[0] == Context.class)
                        && (parameterType[1] == ProviderInfo.class)) {
                    declaredMethod.setAccessible(true);
                    attachInfoMethod = declaredMethod;
                    break;
                }
            }
        }
        assume().withMessage("The 'attachInfo()' method was not found in 'ContentProvider' class")
                .that(attachInfoMethod)
                .isNotNull();
        attachInfoMethod.invoke(targetClassInstance, null /* context */, null /* info */);

        // Fetch the 'query()' method of target class and invoke it to reproduce the issue
        final Method queryMethodOfTargetClass =
                targetClass.getDeclaredMethod(
                        "query",
                        Uri.class,
                        String[].class,
                        String.class,
                        String[].class,
                        String.class);
        queryMethodOfTargetClass.setAccessible(true);
        try {
            queryMethodOfTargetClass.invoke(
                    targetClassInstance,
                    mIsClassSmsProvider ? mContentUriForSms : mContentUriForMms,
                    null /* projection */,
                    null /* selection */,
                    null /* selectionArgs */,
                    null /* sortOrder */);
            return false;
        } catch (InvocationTargetException e) {
            // An exception has occurred due to access of the passed arguments.
            // Return true indicating fix is missing.
            return true;
        }
    }

    private boolean insert(Class targetClass, Object targetClassInstance) throws Exception {
        // Fetch the 'insert()' / 'insertInner()' method of target class and invoke it
        // to reproduce the issue
        final boolean isSdkVersionAboveTiramisu = SDK_INT > 33 /* TIRAMISU */;
        final Method insertMethodOfTargetClass =
                mIsClassSmsProvider
                        ? isSdkVersionAboveTiramisu
                                ? targetClass.getDeclaredMethod(
                                        "insertInner",
                                        Uri.class,
                                        ContentValues.class,
                                        int.class,
                                        String.class,
                                        UserHandle.class)
                                : targetClass.getDeclaredMethod(
                                        "insertInner",
                                        Uri.class,
                                        ContentValues.class,
                                        int.class,
                                        String.class)
                        : targetClass.getDeclaredMethod("insert", Uri.class, ContentValues.class);
        insertMethodOfTargetClass.setAccessible(true);
        try {
            if (mIsClassSmsProvider) {
                if (isSdkVersionAboveTiramisu) {
                    insertMethodOfTargetClass.invoke(
                            targetClassInstance,
                            mContentUriForSms,
                            null /* initialValues */,
                            0 /* callerUid */,
                            null /* callerPkg */,
                            null /* callerUserHandle */);
                } else {
                    insertMethodOfTargetClass.invoke(
                            targetClassInstance,
                            mContentUriForSms,
                            null /* initialValues */,
                            0 /* callerUid */,
                            null /* callerPkg */);
                }
            } else {
                insertMethodOfTargetClass.invoke(
                        targetClassInstance, mContentUriForMms, null /* values */);
            }
            return false;
        } catch (InvocationTargetException e) {
            // An exception has occurred due to access of the passed arguments.
            // Return true indicating fix is missing.
            return true;
        }
    }

    private boolean update(Class targetClass, Object targetClassInstance) throws Exception {
        // Fetch the 'update()' method of target class and invoke it to reproduce the issue
        final Method updateMethodOfTargetClass =
                targetClass.getDeclaredMethod(
                        "update", Uri.class, ContentValues.class, String.class, String[].class);
        updateMethodOfTargetClass.setAccessible(true);
        try {
            updateMethodOfTargetClass.invoke(
                    targetClassInstance,
                    mIsClassSmsProvider ? mContentUriForSms : mContentUriForMms,
                    null /* values */,
                    null /* selection */,
                    null /* selectionArgs */);
            return false;
        } catch (InvocationTargetException e) {
            // An exception has occurred due to access of the passed arguments.
            // Return true indicating fix is missing.
            return true;
        }
    }

    private boolean delete(Class targetClass, Object targetClassInstance) throws Exception {
        // Fetch the 'delete()' method of target class and invoke it to reproduce the issue
        final Method deleteMethodOfTargetClass =
                targetClass.getDeclaredMethod("delete", Uri.class, String.class, String[].class);
        deleteMethodOfTargetClass.setAccessible(true);
        try {
            deleteMethodOfTargetClass.invoke(
                    targetClassInstance,
                    mIsClassSmsProvider ? mContentUriForSms : mContentUriForMms,
                    null /* selection */,
                    null /* selectionArgs */);
            return false;
        } catch (InvocationTargetException e) {
            // An exception has occurred due to access of the passed arguments.
            // Return true indicating fix is missing.
            return true;
        }
    }
}
