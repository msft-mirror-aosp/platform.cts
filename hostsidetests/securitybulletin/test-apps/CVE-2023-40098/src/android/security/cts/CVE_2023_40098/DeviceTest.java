/*
 * Copyright (C) 2024 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package android.security.cts.CVE_2023_40098;

import static android.content.pm.LauncherApps.ACTION_CONFIRM_PIN_SHORTCUT;

import static androidx.test.platform.app.InstrumentationRegistry.getInstrumentation;

import static com.android.sts.common.DumpsysUtils.isActivityVisible;
import static com.android.sts.common.SystemUtil.poll;

import static com.google.common.truth.Truth.assertWithMessage;
import static com.google.common.truth.TruthJUnit.assume;

import android.app.Instrumentation;
import android.app.Notification;
import android.app.NotificationChannel;
import android.app.NotificationManager;
import android.app.PendingIntent;
import android.app.Person;
import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.content.pm.ShortcutInfo;
import android.content.pm.ShortcutManager;
import android.graphics.drawable.Icon;
import android.os.Build;
import android.os.UserManager;
import android.service.notification.StatusBarNotification;

import androidx.test.runner.AndroidJUnit4;
import androidx.test.uiautomator.By;
import androidx.test.uiautomator.UiDevice;
import androidx.test.uiautomator.UiObject2;
import androidx.test.uiautomator.Until;

import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.regex.Pattern;

@RunWith(AndroidJUnit4.class)
public class DeviceTest {

    @Test
    public void testPocCVE_2023_40098() {
        try {
            final Instrumentation instrumentation = getInstrumentation();
            final Context context = instrumentation.getContext();

            // Check if the device supports multiple users or not
            assume().withMessage("This device does not support multiple users")
                    .that(context.getSystemService(UserManager.class).supportsMultipleUsers())
                    .isTrue();

            // Create icon
            final Icon icon =
                    Icon.createWithData(new byte[0] /* data */, 0 /* offset */, 0 /* length */);

            // Create person
            final Person person =
                    new Person.Builder()
                            .setName("cve_2023_40098_person" /* person name */)
                            .setIcon(icon)
                            .setImportant(true)
                            .build();

            // Get instance of ShortcutManager class to publish a single dynamic shortcut
            final String shortcutId = "shortcutId";
            context.getSystemService(ShortcutManager.class)
                    .pushDynamicShortcut(
                            new ShortcutInfo.Builder(context, shortcutId)
                                    .setIntent(new Intent(Intent.ACTION_MAIN))
                                    .setLongLived(true)
                                    .setShortLabel(shortcutId)
                                    .build());

            // Create style for messageStyle notification
            final String message = "cve_2023_40098_message";
            final Notification.MessagingStyle style =
                    new Notification.MessagingStyle(person)
                            .addMessage(
                                    new Notification.MessagingStyle.Message(
                                            message, System.currentTimeMillis(), person))
                            .setConversationTitle(message);

            // Create notification channel
            final NotificationManager notificationManager =
                    context.getSystemService(NotificationManager.class);
            final String notificationChannelId = "notificationChannelId";
            final NotificationChannel notificationChannel =
                    new NotificationChannel(
                            notificationChannelId,
                            "notificationChannelName" /* notification channel name */,
                            NotificationManager.IMPORTANCE_HIGH);
            notificationManager.createNotificationChannel(notificationChannel);

            // Fetch and add the flag 'FLAG_ALLOW_UNSAFE_IMPLICIT_INTENT' for 'Upside Down Cake'
            // and above versions to keep the code consistent
            final int requiredFlag =
                    Build.VERSION.SDK_INT >= 34 /* Upside Down Cake */
                            ? (int)
                                    PendingIntent.class
                                            .getField("FLAG_ALLOW_UNSAFE_IMPLICIT_INTENT")
                                            .get(null)
                            : 0;

            // Post the notification
            // 'FLAG_MUTABLE' is used instead of 'FLAG_IMMUTABLE' since pendingIntent for a bubble
            // notification must be mutable
            notificationManager.notify(
                    0 /* notification id */,
                    new Notification.Builder(context, notificationChannelId)
                            .setStyle(style)
                            .setCategory(Notification.CATEGORY_MESSAGE)
                            .setShortcutId(shortcutId)
                            .setBubbleMetadata(
                                    new Notification.BubbleMetadata.Builder(
                                                    PendingIntent.getActivity(
                                                            context,
                                                            0 /* request code */,
                                                            new Intent(),
                                                            PendingIntent.FLAG_MUTABLE
                                                                    | requiredFlag),
                                                    icon)
                                            .build())
                            .setSmallIcon(icon)
                            .addPerson(person)
                            .build());

            // Check if notification is posted or not
            assume().withMessage("Notification was not posted successfully")
                    .that(
                            poll(
                                    () -> {
                                        StatusBarNotification[] activeNotifications =
                                                notificationManager.getActiveNotifications();
                                        for (StatusBarNotification notification :
                                                activeNotifications) {
                                            if (notification
                                                    .getPackageName()
                                                    .equals(context.getPackageName())) {
                                                return true;
                                            }
                                        }
                                        return false;
                                    }))
                    .isTrue();

            // Get instance of UiDevice
            final UiDevice uiDevice = UiDevice.getInstance(instrumentation);

            // Launch notification shade
            assume().withMessage("Notification shade was not launched")
                    .that(uiDevice.openNotification())
                    .isTrue();

            // Change priority of notification from default to priority
            // Long press on the 'notification' to display the options to change priority
            final long timeout = 10_000L;
            waitForUiObject(uiDevice, message, timeout).click(timeout);

            // Click on 'priority' text to change priority of the notification
            waitForUiObject(uiDevice, "Priority", timeout).click();

            // Click on 'apply' to confirm the priority changed above
            waitForUiObject(uiDevice, "Apply", timeout).click();

            // Switch user to primary user
            final int primaryUser = 0;
            uiDevice.executeShellCommand(String.format("am switch-user %d", primaryUser));

            // Check if user was switched to primary user or not
            assume().withMessage("Unable to switch user")
                    .that(
                            Integer.parseInt(
                                            (uiDevice.executeShellCommand("am get-current-user"))
                                                    .trim())
                                    == primaryUser)
                    .isTrue();

            // Fail the test if widget(com.android.launcher3/.dragndrop.AddItemActivity)
            // appears on the homescreen of primary user
            assertWithMessage(
                            "Device is vulnerable to b/288896269 hence important conversation"
                                    + " messages can be leaked to another user profile due to"
                                    + " incorrect request of pin people space widget by SystemUI")
                    .that(poll(() -> isActivityVisible(fetchAddItemActivityName(context))))
                    .isFalse();
        } catch (Exception e) {
            assume().that(e).isNull();
        }
    }

    private UiObject2 waitForUiObject(UiDevice uiDevice, String text, long timeout) {
        // Fetch and return the UiObject with the specific text.
        final UiObject2 uiObject =
                uiDevice.wait(
                        Until.findObject(By.text(Pattern.compile(text, Pattern.CASE_INSENSITIVE))),
                        timeout);
        assume().withMessage("Unable to find the ui-object with text : " + text)
                .that(uiObject)
                .isNotNull();
        return uiObject;
    }

    private String fetchAddItemActivityName(Context context) {
        return context.getPackageManager()
                .resolveActivity(
                        new Intent(ACTION_CONFIRM_PIN_SHORTCUT), PackageManager.MATCH_SYSTEM_ONLY)
                .activityInfo
                .name;
    }
}
