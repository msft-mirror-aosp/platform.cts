/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package android.server.wm.intent;

import static android.app.WindowConfiguration.WINDOWING_MODE_FREEFORM;
import static android.app.WindowConfiguration.WINDOWING_MODE_FULLSCREEN;
import static android.app.WindowConfiguration.WINDOWING_MODE_MULTI_WINDOW;
import static android.app.WindowConfiguration.WINDOWING_MODE_PINNED;
import static android.app.WindowConfiguration.WINDOWING_MODE_UNDEFINED;

import static java.util.stream.Collectors.toList;

import android.content.ComponentName;
import android.content.Intent;
import android.net.Uri;
import android.server.wm.WindowManagerState;

import com.google.common.collect.Lists;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * The intent tests are generated by running a series of intents and then recording the end state
 * of the system. This class contains all the models needed to store the intents that were used to
 * create the test case and the end states so that they can be asserted on.
 *
 * All test cases are serialized to JSON and stored in a single file per testcase.
 */
public class Persistence {

    /**
     * The highest level entity in the JSON file
     */
    public static class TestCase {
        private static final String SETUP_KEY = "setup";
        private static final String INITIAL_STATES_KEY = "initialStates";
        private static final String END_STATES_KEY = "endStates";

        /**
         * Contains the {@link android.content.Intent}-s that will be launched in this test case.
         */
        private final Setup mSetup;

        /**
         * The possible states of the system after the {@link Setup#mInitialIntents} have been
         * launched. These are organized by launched windowing mode.
         */
        private final List<StateDump> mInitialStates;

        /**
         * The possible states of the system after the {@link Setup#mAct} have been launched. These
         * are organized by launched windowing mode.
         */
        private final List<StateDump> mEndStates;

        /**
         * The name of the testCase, usually the file name it is stored in.
         * Not actually persisted to json, since it is only used for presentation purposes.
         */
        private final String mName;

        public TestCase(Setup setup, List<StateDump> initialStates,
                List<StateDump> endStates, String name) {
            mSetup = setup;
            mInitialStates = initialStates;
            mEndStates = endStates;
            mName = name;
        }

        public JSONObject toJson() throws JSONException {
            return new JSONObject()
                    .put(SETUP_KEY, mSetup.toJson())
                    .put(INITIAL_STATES_KEY, stateDumpsToJson(mInitialStates))
                    .put(END_STATES_KEY, stateDumpsToJson(mEndStates));
        }

        public static TestCase fromJson(JSONObject object,
                Map<String, IntentFlag> table, String name) throws JSONException {
            return new TestCase(Setup.fromJson(object.getJSONObject(SETUP_KEY), table),
                    stateDumpsFromJson(object.getJSONArray(INITIAL_STATES_KEY)),
                    stateDumpsFromJson(object.getJSONArray(END_STATES_KEY)), name);
        }

        public static JSONArray stateDumpsToJson(List<StateDump> stateDumps)
                throws JSONException {
            JSONArray stateDumpArray = new JSONArray();
            for (StateDump stateDump : stateDumps) {
                stateDumpArray.put(stateDump.toJson());
            }
            return stateDumpArray;
        }

        public static List<StateDump> stateDumpsFromJson(
                JSONArray stateDumpsArray) throws JSONException {
            List<StateDump> stateDumps = new ArrayList<>();
            for (int i = 0; i < stateDumpsArray.length(); i++) {
                JSONObject object = (JSONObject) stateDumpsArray.get(i);
                StateDump stateDump = StateDump.fromJson(object);
                stateDumps.add(stateDump);
            }
            return stateDumps;
        }

        public Setup getSetup() {
            return mSetup;
        }

        /**
         * Returns the initial state with the matching launched windowing mode. If no matching
         * launched windowing mode is found, use the default initial state.
         */
        public StateDump getInitialStateWithLaunchedWindowingModeOrDefault(
                String launchedWindowingMode) {
            StateDump defaultInitialState = null;
            for (StateDump initialState : mInitialStates) {
                if (Objects.equals(initialState.mLaunchedWindowingMode, launchedWindowingMode)) {
                    return initialState;
                } else if (Objects.equals(initialState.mLaunchedWindowingMode,
                        StateDump.DEFAULT_LAUNCHED_WINDOWING_MODE)) {
                    defaultInitialState = initialState;
                }
            }
            if (defaultInitialState == null) {
                throw new RuntimeException(
                        "No initial state with default launched windowing mode found");
            }
            return defaultInitialState;
        }

        public String getName() {
            return mName;
        }

        /**
         * Returns the end state with the matching launched windowing mode. If no matching
         * launched windowing mode is found, use the default end state.
         */
        public StateDump getEndStateWithLaunchedWindowingModeOrDefault(
                String launchedWindowingMode) {
            StateDump defaultEndState = null;
            for (StateDump endState : mEndStates) {
                if (Objects.equals(endState.mLaunchedWindowingMode, launchedWindowingMode)) {
                    return endState;
                } else if (Objects.equals(endState.mLaunchedWindowingMode,
                        StateDump.DEFAULT_LAUNCHED_WINDOWING_MODE)) {
                    defaultEndState = endState;
                }
            }
            if (defaultEndState == null) {
                throw new RuntimeException(
                        "No end state with default launched windowing mode found");
            }
            return defaultEndState;
        }
    }

    /**
     * Setup consists of two stages. Firstly a list of intents to bring the system in the state we
     * want to test something in. Secondly a list of intents to bring the system to the final state.
     */
    public static class Setup {
        private static final String INITIAL_INTENT_KEY = "initialIntents";
        private static final String ACT_KEY = "act";
        /**
         * The intent(s) used to bring the system to the initial state.
         */
        private final List<GenerationIntent> mInitialIntents;

        /**
         * The intent(s) that we actually want to test.
         */
        private final List<GenerationIntent> mAct;

        public Setup(List<GenerationIntent> initialIntents, List<GenerationIntent> act) {
            mInitialIntents = initialIntents;
            mAct = act;
        }

        public List<ComponentName> componentsInCase() {
            return Stream.concat(mInitialIntents.stream(), mAct.stream())
                    .map(GenerationIntent::getActualIntent)
                    .map(Intent::getComponent)
                    .collect(Collectors.toList());
        }

        public JSONObject toJson() throws JSONException {
            return new JSONObject()
                    .put(INITIAL_INTENT_KEY, intentsToJson(mInitialIntents))
                    .put(ACT_KEY, intentsToJson(mAct));
        }

        public static Setup fromJson(JSONObject object,
                Map<String, IntentFlag> table) throws JSONException {
            List<GenerationIntent> initialState = intentsFromJson(
                    object.getJSONArray(INITIAL_INTENT_KEY), table);
            List<GenerationIntent> act = intentsFromJson(object.getJSONArray(ACT_KEY), table);

            return new Setup(initialState, act);
        }

        public static JSONArray intentsToJson(List<GenerationIntent> intents)
                throws JSONException {

            JSONArray intentArray = new JSONArray();
            for (GenerationIntent intent : intents) {
                intentArray.put(intent.toJson());
            }
            return intentArray;
        }

        public static List<GenerationIntent> intentsFromJson(JSONArray intentArray,
                Map<String, IntentFlag> table) throws JSONException {
            List<GenerationIntent> intents = new ArrayList<>();

            for (int i = 0; i < intentArray.length(); i++) {
                JSONObject object = (JSONObject) intentArray.get(i);
                GenerationIntent intent = GenerationIntent.fromJson(object, table);

                intents.add(intent);
            }

            return intents;
        }

        public List<GenerationIntent> getInitialIntents() {
            return mInitialIntents;
        }

        public List<GenerationIntent> getAct() {
            return mAct;
        }
    }

    /**
     * An representation of an {@link android.content.Intent} that can be (de)serialized to / from
     * JSON. It abstracts whether the context it should be started from is implicitly or explicitly
     * specified.
     */
    interface GenerationIntent {
        Intent getActualIntent();

        JSONObject toJson() throws JSONException;

        int getLaunchFromIndex(int currentPosition);

        boolean startForResult();

        static GenerationIntent fromJson(JSONObject object, Map<String, IntentFlag> table)
                throws JSONException {
            if (object.has(LaunchFromIntent.LAUNCH_FROM_KEY)) {
                return LaunchFromIntent.fromJson(object, table);
            } else {
                return LaunchIntent.fromJson(object, table);
            }
        }
    }

    /**
     * Representation of {@link android.content.Intent} used by the {@link LaunchSequence} api.
     * It be can used to normally start activities, to start activities for result and Intent Flags
     * can be added using {@link LaunchIntent#withFlags(IntentFlag...)}
     */
    static class LaunchIntent implements GenerationIntent {
        private static final String FLAGS_KEY = "flags";
        private static final String PACKAGE_KEY = "package";
        private static final String CLASS_KEY = "class";
        private static final String DATA_KEY = "data";
        private static final String START_FOR_RESULT_KEY = "startForResult";

        private final List<IntentFlag> mIntentFlags;
        private final ComponentName mComponentName;
        private final String mData;
        private final boolean mStartForResult;

        public LaunchIntent(List<IntentFlag> intentFlags, ComponentName componentName, String data,
                boolean startForResult) {
            mIntentFlags = intentFlags;
            mComponentName = componentName;
            mData = data;
            mStartForResult = startForResult;
        }

        @Override
        public Intent getActualIntent() {
            final Intent intent = new Intent().setComponent(mComponentName).setFlags(buildFlag());
            if (mData != null && !mData.isEmpty()) {
                intent.setData(Uri.parse(mData));
            }
            return intent;
        }

        @Override
        public int getLaunchFromIndex(int currentPosition) {
            return currentPosition - 1;
        }

        @Override
        public boolean startForResult() {
            return mStartForResult;
        }

        public int buildFlag() {
            int flag = 0;
            for (IntentFlag intentFlag : mIntentFlags) {
                flag |= intentFlag.flag;
            }

            return flag;
        }

        public String humanReadableFlags() {
            return mIntentFlags.stream().map(IntentFlag::toString).collect(
                    Collectors.joining(" | "));
        }

        public static LaunchIntent fromJson(JSONObject fakeIntent, Map<String, IntentFlag> table)
                throws JSONException {
            List<IntentFlag> flags = IntentFlag.parse(table, fakeIntent.getString(FLAGS_KEY));

            boolean startForResult = fakeIntent.optBoolean(START_FOR_RESULT_KEY, false);
            String uri = fakeIntent.optString(DATA_KEY);
            return new LaunchIntent(flags,
                    new ComponentName(
                            fakeIntent.getString(PACKAGE_KEY),
                            fakeIntent.getString(CLASS_KEY)),
                            uri,
                            startForResult);
        }

        @Override
        public JSONObject toJson() throws JSONException {
            return new JSONObject().put(FLAGS_KEY, this.humanReadableFlags())
                    .put(CLASS_KEY, this.mComponentName.getClassName())
                    .put(PACKAGE_KEY, this.mComponentName.getPackageName())
                    .put(START_FOR_RESULT_KEY, mStartForResult);
        }

        public LaunchIntent withFlags(IntentFlag... flags) {
            List<IntentFlag> intentFlags = Lists.newArrayList(mIntentFlags);
            Collections.addAll(intentFlags, flags);
            return new LaunchIntent(intentFlags, mComponentName, mData, mStartForResult);
        }

        public List<IntentFlag> getIntentFlags() {
            return mIntentFlags;
        }

        public ComponentName getComponentName() {
            return mComponentName;
        }
    }

    /**
     * Representation of {@link android.content.Intent} used by the {@link LaunchSequence} api.
     * It can used to normally start activities, to start activities for result and Intent Flags
     * can
     * be added using {@link LaunchIntent#withFlags(IntentFlag...)} just like {@link LaunchIntent}
     *
     * However {@link LaunchFromIntent}  also supports launching from a activity earlier in the
     * launch sequence. This can be done using {@link LaunchSequence#act} and related methods.
     */
    static class LaunchFromIntent implements GenerationIntent {
        static final String LAUNCH_FROM_KEY = "launchFrom";

        /**
         * The underlying {@link LaunchIntent} that we are wrapping with the launch point behaviour.
         */
        private final LaunchIntent mLaunchIntent;

        /**
         * The index in the activityLog maintained by {@link LaunchRunner}, used to retrieve the
         * activity from the log to start this {@link LaunchIntent} from.
         */
        private final int mLaunchFrom;

        LaunchFromIntent(LaunchIntent fakeIntent, int launchFrom) {
            mLaunchIntent = fakeIntent;
            mLaunchFrom = launchFrom;
        }


        @Override
        public Intent getActualIntent() {
            return mLaunchIntent.getActualIntent();
        }

        @Override
        public int getLaunchFromIndex(int currentPosition) {
            return mLaunchFrom;
        }

        @Override
        public boolean startForResult() {
            return mLaunchIntent.mStartForResult;
        }

        @Override
        public JSONObject toJson() throws JSONException {
            return mLaunchIntent.toJson()
                    .put(LAUNCH_FROM_KEY, mLaunchFrom);
        }

        public static LaunchFromIntent fromJson(JSONObject object, Map<String, IntentFlag> table)
                throws JSONException {
            LaunchIntent fakeIntent = LaunchIntent.fromJson(object, table);
            int launchFrom = object.optInt(LAUNCH_FROM_KEY, -1);

            return new LaunchFromIntent(fakeIntent, launchFrom);
        }

        static List<GenerationIntent> prepareSerialisation(List<LaunchFromIntent> intents) {
            return prepareSerialisation(intents, 0);
        }

        // In serialized form we only want to store the launch from index if it deviates from the
        // default, the default being the previous activity.
        static List<GenerationIntent> prepareSerialisation(List<LaunchFromIntent> intents,
                int base) {
            List<GenerationIntent> serializeIntents = Lists.newArrayList();
            for (int i = 0; i < intents.size(); i++) {
                LaunchFromIntent launchFromIntent = intents.get(i);
                serializeIntents.add(launchFromIntent.forget(base + i));
            }

            return serializeIntents;
        }

        public GenerationIntent forget(int currentIndex) {
            if (mLaunchFrom == currentIndex - 1) {
                return this.mLaunchIntent;
            } else {
                return this;
            }
        }

        public int getLaunchFrom() {
            return mLaunchFrom;
        }
    }

    /**
     * An intent flag that also stores the name of the flag.
     * It is used to be able to put the flags in human readable form in the JSON file.
     */
    static class IntentFlag {
        /**
         * The underlying flag, should be a value from Intent.FLAG_ACTIVITY_*.
         */
        public final int flag;
        /**
         * The name of the flag.
         */
        public final String name;

        public IntentFlag(int flag, String name) {
            this.flag = flag;
            this.name = name;
        }

        public int getFlag() {
            return flag;
        }

        public String getName() {
            return name;
        }

        public int combine(IntentFlag other) {
            return other.flag | flag;
        }

        public static List<IntentFlag> parse(Map<String, IntentFlag> names, String flagsToParse) {
            String[] split = flagsToParse.replaceAll("\\s", "").split("\\|");
            return Arrays.stream(split).map(names::get).collect(toList());
        }

        public String toString() {
            return name;
        }
    }

    static IntentFlag flag(int flag, String name) {
        return new IntentFlag(flag, name);
    }

    /**
     * A windowing mode class that also stores the name of the windowing mode.
     * It is used to be able to put the modes in human readable form in the JSON file.
     */
    public static class ReadableWindowingMode {
        /**
         * The underlying mode, should be a value from WindowConfiguration.WINDOWING_MODE_*.
         */
        public final int windowingMode;

        /**
         * The name of the windowing mode.
         */
        public final String name;

        public ReadableWindowingMode(int windowingMode, String name) {
            this.windowingMode = windowingMode;
            this.name = name;
        }

        public int getWindowingMode() {
            return windowingMode;
        }

        public String getName() {
            return name;
        }

        public String toString() {
            return name;
        }

        static ReadableWindowingMode covert(int windowingMode) {
            return switch (windowingMode) {
                case WINDOWING_MODE_FULLSCREEN -> new ReadableWindowingMode(windowingMode,
                        "WINDOWING_MODE_FULLSCREEN");
                case WINDOWING_MODE_PINNED -> new ReadableWindowingMode(windowingMode,
                        "WINDOWING_MODE_PINNED");
                case WINDOWING_MODE_FREEFORM -> new ReadableWindowingMode(windowingMode,
                        "WINDOWING_MODE_FREEFORM");
                case WINDOWING_MODE_MULTI_WINDOW -> new ReadableWindowingMode(windowingMode,
                        "WINDOWING_MODE_MULTI_WINDOW");
                default -> new ReadableWindowingMode(windowingMode,
                        StateDump.DEFAULT_LAUNCHED_WINDOWING_MODE);
            };
        }
    }

    public static class StateDump {
        private static final String TASKS_KEY = "tasks";
        private static final String LAUNCHED_WINDOWING_MODE_KEY = "launchedWindowingMode";
        private static final String DEFAULT_LAUNCHED_WINDOWING_MODE = "WINDOWING_MODE_UNDEFINED";

        /**
         * The Tasks in this stack ordered from most recent to least recent.
         */
        private final List<TaskState> mTasks;

        /**
         * The windowing mode of which tasks in this stack are launched in.
         */
        private final String mLaunchedWindowingMode;

        public static StateDump fromTasks(List<WindowManagerState.Task> activityTasks,
                List<WindowManagerState.Task> baseStacks) {
            List<TaskState> tasks = new ArrayList<>();
            int launchedWindowingMode = WINDOWING_MODE_UNDEFINED;
            for (WindowManagerState.Task task : trimTasks(activityTasks, baseStacks)) {
                tasks.add(new TaskState(task));
                if (launchedWindowingMode != task.getWindowingMode()) {
                    launchedWindowingMode = task.getWindowingMode();
                }
            }
            Persistence.ReadableWindowingMode readableLaunchedWindowingMode =
                    Persistence.ReadableWindowingMode.covert(launchedWindowingMode);
            return new StateDump(tasks, readableLaunchedWindowingMode.getName());
        }

        private StateDump(List<TaskState> tasks, String launchedWindowingMode) {
            mTasks = tasks;
            mLaunchedWindowingMode = launchedWindowingMode;
        }

        JSONObject toJson() throws JSONException {
            JSONArray tasks = new JSONArray();
            for (TaskState task : mTasks) {
                tasks.put(task.toJson());
            }

            return new JSONObject()
                    .put(TASKS_KEY, tasks)
                    .put(LAUNCHED_WINDOWING_MODE_KEY, mLaunchedWindowingMode);
        }

        static StateDump fromJson(JSONObject object) throws JSONException {
            JSONArray jsonTasks = object.getJSONArray(TASKS_KEY);
            List<TaskState> tasks = new ArrayList<>();

            for (int i = 0; i < jsonTasks.length(); i++) {
                tasks.add(TaskState.fromJson((JSONObject) jsonTasks.get(i)));
            }

            return new StateDump(tasks, object.getString(LAUNCHED_WINDOWING_MODE_KEY));
        }

        /**
         * To make the state dump non device specific we remove every task that was present
         * in the system before recording, by their ID. For example a task containing the launcher
         * activity.
         */
        public static List<WindowManagerState.Task> trimTasks(
                List<WindowManagerState.Task> toTrim,
                List<WindowManagerState.Task> trimFrom) {

            for (WindowManagerState.Task task : trimFrom) {
                toTrim.removeIf(t -> t.getRootTaskId() == task.getRootTaskId());
            }

            return toTrim;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            StateDump stateDump = (StateDump) o;
            final boolean defaultLaunchedWindowingModeUsed =
                    Objects.equals(mLaunchedWindowingMode, DEFAULT_LAUNCHED_WINDOWING_MODE)
                            || Objects.equals(stateDump.mLaunchedWindowingMode,
                                    DEFAULT_LAUNCHED_WINDOWING_MODE);
            final boolean launchedWindowingModeEqualOrDefault =
                    Objects.equals(mLaunchedWindowingMode, stateDump.mLaunchedWindowingMode)
                            || defaultLaunchedWindowingModeUsed;
            return Objects.equals(mTasks, stateDump.mTasks) && launchedWindowingModeEqualOrDefault;
        }

        @Override
        public int hashCode() {
            return Objects.hash(mTasks, mLaunchedWindowingMode);
        }
    }

    public static class TaskState {

        private static final String STATE_RESUMED = "RESUMED";
        private static final String ACTIVITIES_KEY = "activities";

        /**
         * The component name of the resumedActivity in this state, empty string if there is none.
         */
        private final String mResumedActivity;

        /**
         * The activities in this task ordered from most recent to least recent.
         */
        private final List<ActivityState> mActivities = new ArrayList<>();

        private TaskState(JSONArray jsonActivities) throws JSONException {
            String resumedActivity = "";
            for (int i = 0; i < jsonActivities.length(); i++) {
                final ActivityState activity =
                        ActivityState.fromJson((JSONObject) jsonActivities.get(i));
                // The json file shouldn't define multiple resumed activities, but it is fine that
                // the test will fail when comparing to the real state.
                if (STATE_RESUMED.equals(activity.getState())) {
                    resumedActivity = activity.getName();
                }
                mActivities.add(activity);
            }

            mResumedActivity = resumedActivity;
        }

        public TaskState(WindowManagerState.Task state) {
            final String resumedActivity = state.getResumedActivity();
            mResumedActivity = resumedActivity != null ? resumedActivity : "";
            for (WindowManagerState.Activity activity : state.getActivities()) {
                this.mActivities.add(new ActivityState(activity));
            }
        }

        JSONObject toJson() throws JSONException {
            JSONArray jsonActivities = new JSONArray();

            for (ActivityState activity : mActivities) {
                jsonActivities.put(activity.toJson());
            }

            return new JSONObject()
                    .put(ACTIVITIES_KEY, jsonActivities);
        }

        static TaskState fromJson(JSONObject object) throws JSONException {
            return new TaskState(object.getJSONArray(ACTIVITIES_KEY));
        }

        public List<ActivityState> getActivities() {
            return mActivities;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            TaskState task = (TaskState) o;
            return Objects.equals(mResumedActivity, task.mResumedActivity)
                    && Objects.equals(mActivities, task.mActivities);
        }

        @Override
        public int hashCode() {
            return Objects.hash(mResumedActivity, mActivities);
        }
    }

    public static class ActivityState {
        private static final String NAME_KEY = "name";
        private static final String STATE_KEY = "state";
        /**
         * The componentName of this activity.
         */
        private final String mComponentName;

        /**
         * The lifecycle state this activity is in.
         */
        private final String mLifeCycleState;

        public ActivityState(String name, String state) {
            mComponentName = name;
            mLifeCycleState = state;
        }

        public ActivityState(WindowManagerState.Activity activity) {
            mComponentName = activity.getName();
            mLifeCycleState = activity.getState();
        }


        JSONObject toJson() throws JSONException {
            return new JSONObject().put(NAME_KEY, mComponentName).put(STATE_KEY, mLifeCycleState);
        }

        static ActivityState fromJson(JSONObject object) throws JSONException {
            return new ActivityState(object.getString(NAME_KEY), object.getString(STATE_KEY));
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            ActivityState activity = (ActivityState) o;
            return Objects.equals(mComponentName, activity.mComponentName) &&
                    Objects.equals(mLifeCycleState, activity.mLifeCycleState);
        }

        @Override
        public int hashCode() {
            return Objects.hash(mComponentName, mLifeCycleState);
        }

        public String getName() {
            return mComponentName;
        }

        public String getState() {
            return mLifeCycleState;
        }
    }
}
